{
  "version": 3,
  "sources": ["../src/shared/messages.ts", "../src/content/button-styles.ts", "../src/content/shared/button-controller.ts", "../src/content/shared/types.ts", "../src/content/sites/chatgpt.ts", "../src/content/sites/manus.ts", "../src/content/sites/gemini.ts", "../src/content/shared/mutation-observer-helpers.ts", "../src/content/index.ts"],
  "sourcesContent": ["export const MessageType = {\n  OptimizePrompt: 'OPTIMIZE_PROMPT',\n  TriggerOptimize: 'TRIGGER_OPTIMIZE'\n} as const;\n\nexport type MessageKind = typeof MessageType[keyof typeof MessageType];\n\nexport type OptimizePromptRequest = {\n  type: typeof MessageType.OptimizePrompt;\n  payload: {\n    originalPrompt: string;\n    styleId?: string;\n    source?: 'content-script' | 'popup';\n    pageHost?: string;\n  };\n};\n\nexport type OptimizePromptResponse = {\n  success: boolean;\n  optimizedPrompt?: string;\n  error?: string;\n};\n\nexport type TriggerOptimizeMessage = {\n  type: typeof MessageType.TriggerOptimize;\n};\n\nexport function isOptimizePromptRequest(message: unknown): message is OptimizePromptRequest {\n  if (!message || typeof message !== 'object') return false;\n  const typed = message as OptimizePromptRequest;\n  return typed.type === MessageType.OptimizePrompt && Boolean(typed.payload?.originalPrompt);\n}\n\nexport function isTriggerOptimizeMessage(message: unknown): message is TriggerOptimizeMessage {\n  if (!message || typeof message !== 'object') return false;\n  const typed = message as TriggerOptimizeMessage;\n  return typed.type === MessageType.TriggerOptimize;\n}\n", "/**\n * Button styling utility module for ChatGPT inline button\n * Most styles are now in content-script.css, this only handles dynamic styling\n */\n\n/**\n * Detects if ChatGPT is currently in dark mode\n * @returns true if dark mode is active, false otherwise\n */\nexport function isDarkMode(): boolean {\n  // ChatGPT uses Tailwind dark mode with 'dark' class on <html>\n  return document.documentElement.classList.contains('dark');\n}\n\n/**\n * Applies minimal dynamic button styles (most styles are in CSS now)\n * @param button - The button element to style\n */\nexport function applyButtonStyles(button: HTMLButtonElement): void {\n  // Most styles are now in content-script.css\n  // This function is kept for backwards compatibility and future dynamic styling needs\n  console.log('[Prompt Optimizer] Button styles applied via CSS');\n}\n\n/**\n * Sets up a MutationObserver to watch for theme changes\n * This is no longer needed as CSS handles dark mode automatically via html.dark selector\n * Kept for compatibility\n * @param button - The button element to update on theme change\n * @returns MutationObserver instance (can be disconnected if needed)\n */\nexport function observeThemeChanges(button: HTMLButtonElement): MutationObserver {\n  const observer = new MutationObserver(() => {\n    const isDark = isDarkMode();\n    console.log('[Prompt Optimizer] Theme changed to:', isDark ? 'dark' : 'light');\n  });\n\n  observer.observe(document.documentElement, {\n    attributes: true,\n    attributeFilter: ['class']\n  });\n\n  return observer;\n}\n", "/**\n * Shared button controller for managing the optimize button across all sites\n * Handles button creation, optimization flow, and state management\n */\n\nimport { MessageType, OptimizePromptResponse } from '../../shared/messages';\nimport { applyButtonStyles, observeThemeChanges } from '../button-styles';\n\nconst BUTTON_CLASS = 'prompt-enhancer-btn';\nconst BUTTON_TEXT = '\u4F18\u5316\u6307\u4EE4';\n\n/**\n * Creates the optimize button element\n * @returns A configured button element ready to be inserted into the DOM\n */\nexport function createButton(): HTMLButtonElement {\n  const button = document.createElement('button');\n  button.type = 'button';\n  button.textContent = BUTTON_TEXT;\n  button.className = BUTTON_CLASS;\n\n  // Apply styles (CSS handles most styling now)\n  applyButtonStyles(button);\n  observeThemeChanges(button);\n\n  return button;\n}\n\n/**\n * Handles the optimize button click - sends prompt to background worker for optimization\n * @param button - The button element (for state updates)\n * @param target - The input element containing the prompt\n * @param getPromptValue - Function to read prompt from input element\n * @param setPromptValue - Function to write optimized prompt to input element\n */\nexport async function handleOptimize(\n  button: HTMLButtonElement,\n  target: HTMLElement,\n  getPromptValue: (el: HTMLElement) => string,\n  setPromptValue: (el: HTMLElement, value: string) => void\n): Promise<void> {\n  console.log('[Prompt Optimizer] Optimize triggered');\n\n  const originalPrompt = getPromptValue(target).trim();\n  if (!originalPrompt) {\n    console.warn('[Prompt Optimizer] Empty prompt');\n    button.textContent = '\u8BF7\u8F93\u5165\u5185\u5BB9';\n    setTimeout(() => (button.textContent = BUTTON_TEXT), 1200);\n    return;\n  }\n\n  console.log('[Prompt Optimizer] Original prompt:', originalPrompt.substring(0, 50) + '...');\n\n  setLoading(button, true);\n  try {\n    console.log('[Prompt Optimizer] Sending request to background...');\n    const response = (await chrome.runtime.sendMessage({\n      type: MessageType.OptimizePrompt,\n      payload: { originalPrompt, source: 'content-script', pageHost: window.location.host }\n    })) as OptimizePromptResponse;\n\n    console.log('[Prompt Optimizer] Response:', response);\n\n    if (!response?.success || !response.optimizedPrompt) {\n      const msg = response?.error || '\u4F18\u5316\u5931\u8D25';\n      console.error('[Prompt Optimizer] Failed:', msg);\n      button.textContent = msg;\n      setTimeout(() => (button.textContent = BUTTON_TEXT), 1400);\n      return;\n    }\n\n    console.log('[Prompt Optimizer] \u2705 Success, updating prompt');\n    setPromptValue(target, response.optimizedPrompt);\n  } catch (error) {\n    console.error('[Prompt Optimizer] Error:', error);\n    button.textContent = '\u8BF7\u6C42\u9519\u8BEF';\n    setTimeout(() => (button.textContent = BUTTON_TEXT), 1400);\n  } finally {\n    setLoading(button, false);\n  }\n}\n\n/**\n * Updates the button's loading state\n * @param button - The button element to update\n * @param loading - True if loading, false if idle\n */\nexport function setLoading(button: HTMLButtonElement, loading: boolean): void {\n  button.disabled = loading;\n  button.textContent = loading ? '\u4F18\u5316\u4E2D\u2026' : BUTTON_TEXT;\n  if (loading) {\n    button.classList.add('loading');\n  } else {\n    button.classList.remove('loading');\n  }\n}\n\n/**\n * Check if the button already exists on the page\n * @returns True if button exists, false otherwise\n */\nexport function buttonExists(): boolean {\n  return !!document.querySelector(`.${BUTTON_CLASS}`);\n}\n\n/**\n * Remove the button from the page\n */\nexport function removeButton(): void {\n  const button = document.querySelector(`.${BUTTON_CLASS}`);\n  if (button) {\n    button.remove();\n    console.log('[Prompt Optimizer] Button removed');\n  }\n}\n", "/**\n * Site-specific handler interface for button injection\n * Defines the contract that each site handler must implement\n */\n\n/**\n * Handler for injecting the optimize button on a specific chat site\n */\nexport interface SiteHandler {\n  /** Hostname patterns this handler supports (e.g., ['chatgpt.com', 'chat.openai.com']) */\n  hostPatterns: string[];\n\n  /** Site name for logging purposes */\n  name: string;\n\n  /** CSS selectors to find the prompt input, in priority order */\n  inputSelectors: string[];\n\n  /**\n   * Find the input element on the page\n   * Tries selectors in priority order\n   * @returns The input element, or null if not found\n   */\n  findPromptInput(): HTMLElement | null;\n\n  /**\n   * Get the current prompt text from the input element\n   * @param input - The input element\n   * @returns The prompt text\n   */\n  getPromptValue(input: HTMLElement): string;\n\n  /**\n   * Set the prompt text in the input element\n   * @param input - The input element\n   * @param value - The new prompt text\n   */\n  setPromptValue(input: HTMLElement, value: string): void;\n\n  /**\n   * Insert the optimize button at the appropriate location on the page\n   * @param button - The button element to insert\n   * @param input - The input element (for reference when deciding placement)\n   * @returns True if insertion succeeded, false if all strategies failed\n   */\n  insertButton(button: HTMLButtonElement, input: HTMLElement): boolean;\n\n  /**\n   * Check if this handler should be active for the current site\n   * @returns True if this is the right handler for the current host\n   */\n  shouldActivate(): boolean;\n}\n\n/**\n * Base implementation of SiteHandler with common functionality\n */\nexport abstract class BaseSiteHandler implements SiteHandler {\n  abstract hostPatterns: string[];\n  abstract name: string;\n  abstract inputSelectors: string[];\n\n  findPromptInput(): HTMLElement | null {\n    console.log(`[Prompt Optimizer] ${this.name}: Trying selectors:`, this.inputSelectors);\n\n    for (const selector of this.inputSelectors) {\n      const el = document.querySelector<HTMLElement>(selector);\n      if (el) {\n        console.log(`[Prompt Optimizer] ${this.name}: \u2705 Found input element:`, selector);\n        return el;\n      }\n    }\n\n    console.warn(`[Prompt Optimizer] ${this.name}: \u274C Could not find input element`);\n    return null;\n  }\n\n  getPromptValue(input: HTMLElement): string {\n    if (input instanceof HTMLTextAreaElement || input instanceof HTMLInputElement) {\n      return input.value || '';\n    }\n    return input.textContent || '';\n  }\n\n  setPromptValue(input: HTMLElement, value: string): void {\n    if (input instanceof HTMLTextAreaElement || input instanceof HTMLInputElement) {\n      input.value = value;\n      input.dispatchEvent(new Event('input', { bubbles: true }));\n      return;\n    }\n    input.textContent = value;\n    input.dispatchEvent(new Event('input', { bubbles: true }));\n  }\n\n  abstract insertButton(button: HTMLButtonElement, input: HTMLElement): boolean;\n\n  shouldActivate(): boolean {\n    return this.hostPatterns.some(pattern => window.location.host.includes(pattern));\n  }\n\n  /**\n   * Helper method to log strategy success/failure\n   */\n  protected logStrategy(strategyNum: number, success: boolean, details: string = '') {\n    if (success) {\n      console.log(`[Prompt Optimizer] ${this.name}: \u2705 Strategy ${strategyNum} succeeded ${details}`);\n    } else {\n      console.warn(`[Prompt Optimizer] ${this.name}: Strategy ${strategyNum} failed ${details}`);\n    }\n  }\n}\n", "/**\n * ChatGPT site handler\n * Implements button injection for chatgpt.com and chat.openai.com\n */\n\nimport { BaseSiteHandler } from '../shared/types';\n\nexport class ChatGptHandler extends BaseSiteHandler {\n  hostPatterns = ['chatgpt.com', 'chat.openai.com'];\n  name = 'ChatGPT';\n  inputSelectors = [\n    'div[role=\"textbox\"]',\n    '#prompt-textarea',\n    'textarea[placeholder*=\"Message\"]'\n  ];\n\n  /**\n   * Insert button with 4-level fallback strategy optimized for ChatGPT's layout\n   */\n  insertButton(button: HTMLButtonElement, input: HTMLElement): boolean {\n    console.log('[Prompt Optimizer] ChatGPT: Trying insertion strategies...');\n\n    // Strategy 1: Try to anchor next to ChatGPT \"+\" button\n    const plusButtonEl = document.querySelector('[data-testid=\"composer-plus-btn\"]');\n    if (plusButtonEl) {\n      const plusContainer = plusButtonEl.parentElement;\n      if (plusContainer) {\n        plusContainer.appendChild(button);\n        this.logStrategy(1, true, '(next to + button)');\n        return true;\n      }\n    }\n    this.logStrategy(1, false);\n\n    // Strategy 2: Try grid-area:leading container\n    const leadingArea = document.querySelector('[class*=\"grid-area:leading\"]');\n    if (leadingArea) {\n      const plusButtonSpan = leadingArea.querySelector('span.flex');\n      if (plusButtonSpan) {\n        plusButtonSpan.appendChild(button);\n        this.logStrategy(2, true, '(grid-area:leading)');\n        return true;\n      }\n    }\n    this.logStrategy(2, false);\n\n    // Strategy 3: Insert before target's parent\n    const parent = input.parentElement;\n    if (parent) {\n      parent.insertBefore(button, input);\n      this.logStrategy(3, true, '(before target parent)');\n      return true;\n    }\n    this.logStrategy(3, false);\n\n    // Strategy 4: Last resort\n    try {\n      input.insertAdjacentElement('beforebegin', button);\n      this.logStrategy(4, true, '(insertAdjacentElement)');\n      return true;\n    } catch (error) {\n      this.logStrategy(4, false);\n      return false;\n    }\n  }\n}\n", "/**\n * Manus.im site handler\n * Implements button injection for manus.im with 4-level fallback strategy\n */\n\nimport { BaseSiteHandler } from '../shared/types';\n\nexport class ManusHandler extends BaseSiteHandler {\n  hostPatterns = ['manus.im'];\n  name = 'Manus';\n  inputSelectors = [\n    'textarea[placeholder=\"Assign a task or ask anything\"]', // Exact match - most specific\n    'textarea[placeholder*=\"Assign\"]', // Partial match - handles variations\n    'textarea[placeholder*=\"ask\"]', // Partial match - case-insensitive fallback\n    'textarea' // Generic fallback - always succeeds\n  ];\n\n  /**\n   * Insert button with 4-level fallback strategy optimized for Manus's layout\n   * Manus uses a flex container with buttons that we anchor to\n   */\n  insertButton(button: HTMLButtonElement, input: HTMLElement): boolean {\n    console.log('[Prompt Optimizer] Manus: Trying insertion strategies...');\n\n    // Strategy 1: Find .flex.gap-2.items-center.flex-shrink-0, locate first button.rounded-full (plus), insert after\n    const flexContainer = document.querySelector('.flex.gap-2.items-center.flex-shrink-0');\n    if (flexContainer) {\n      const plusButton = flexContainer.querySelector('button.rounded-full');\n      if (plusButton && plusButton.nextElementSibling) {\n        // Insert after the plus button with spacing\n        plusButton.parentElement?.insertBefore(button, plusButton.nextElementSibling);\n        this.logStrategy(1, true, '(next to plus button)');\n        return true;\n      } else if (plusButton) {\n        // If no next sibling, append to parent\n        plusButton.parentElement?.appendChild(button);\n        this.logStrategy(1, true, '(after plus button)');\n        return true;\n      }\n    }\n    this.logStrategy(1, false);\n\n    // Strategy 2: Find .flex.gap-2.items-center.flex-shrink-0 and append button as last child\n    const flexContainer2 = document.querySelector('.flex.gap-2.items-center.flex-shrink-0');\n    if (flexContainer2) {\n      flexContainer2.appendChild(button);\n      this.logStrategy(2, true, '(flex.gap-2 container)');\n      return true;\n    }\n    this.logStrategy(2, false);\n\n    // Strategy 3: Find .px-3.flex.gap-2 (action bar) and append button\n    const actionBar = document.querySelector('.px-3.flex.gap-2');\n    if (actionBar) {\n      actionBar.appendChild(button);\n      this.logStrategy(3, true, '(action bar)');\n      return true;\n    }\n    this.logStrategy(3, false);\n\n    // Strategy 4: Last resort - insert before textarea parent\n    const parent = input.parentElement;\n    if (parent) {\n      parent.insertBefore(button, input);\n      this.logStrategy(4, true, '(before target parent)');\n      return true;\n    }\n    this.logStrategy(4, false);\n\n    return false;\n  }\n}\n", "/**\n * Gemini site handler\n * Implements button injection for gemini.google.com with 5-level fallback strategy\n * Includes support for Quill editor (contenteditable div with custom event handling)\n */\n\nimport { BaseSiteHandler } from '../shared/types';\n\nexport class GeminiHandler extends BaseSiteHandler {\n  hostPatterns = ['gemini.google.com'];\n  name = 'Gemini';\n  inputSelectors = [\n    '.ql-editor.textarea[contenteditable=\"true\"][data-placeholder=\"Ask Gemini\"]', // Most specific\n    'div[role=\"textbox\"][aria-label*=\"Enter a prompt here\"]', // Quill editor wrapper\n    'div.ql-editor[contenteditable=\"true\"]', // Quill editor element\n    'rich-textarea div[contenteditable=\"true\"]', // Web component fallback\n    'div[contenteditable=\"true\"]' // Generic contenteditable (least specific)\n  ];\n\n  /**\n   * Insert button with 5-level fallback strategy optimized for Gemini's layout\n   * Gemini uses Material Design with leading-actions-wrapper for action buttons\n   */\n  insertButton(button: HTMLButtonElement, input: HTMLElement): boolean {\n    console.log('[Prompt Optimizer] Gemini: Trying insertion strategies...');\n\n    // Strategy 1: Find .leading-actions-wrapper, insert after upload button (or prepend if absent)\n    const leadingActionsWrapper = document.querySelector('.leading-actions-wrapper');\n    if (leadingActionsWrapper) {\n      const uploadButton = leadingActionsWrapper.querySelector('button[aria-label*=\"upload\" i]');\n      if (uploadButton && uploadButton.nextElementSibling) {\n        uploadButton.parentElement?.insertBefore(button, uploadButton.nextElementSibling);\n        this.logStrategy(1, true, '(after upload button)');\n        return true;\n      } else {\n        // Prepend if upload button not found\n        leadingActionsWrapper.insertBefore(button, leadingActionsWrapper.firstChild);\n        this.logStrategy(1, true, '(leading actions wrapper)');\n        return true;\n      }\n    }\n    this.logStrategy(1, false);\n\n    // Strategy 2: Find .leading-actions-wrapper and append button as last child\n    const leadingActionsWrapper2 = document.querySelector('.leading-actions-wrapper');\n    if (leadingActionsWrapper2) {\n      leadingActionsWrapper2.appendChild(button);\n      this.logStrategy(2, true, '(append to leading actions)');\n      return true;\n    }\n    this.logStrategy(2, false);\n\n    // Strategy 3: Find .text-input-field_textarea-wrapper and insert after rich-textarea\n    const textInputWrapper = document.querySelector('.text-input-field_textarea-wrapper');\n    if (textInputWrapper) {\n      const richTextarea = textInputWrapper.querySelector('rich-textarea');\n      if (richTextarea && richTextarea.nextElementSibling) {\n        richTextarea.parentElement?.insertBefore(button, richTextarea.nextElementSibling);\n        this.logStrategy(3, true, '(after rich-textarea)');\n        return true;\n      } else if (richTextarea) {\n        richTextarea.parentElement?.appendChild(button);\n        this.logStrategy(3, true, '(append to textarea wrapper)');\n        return true;\n      }\n    }\n    this.logStrategy(3, false);\n\n    // Strategy 4: Insert before ql-editor parent element\n    const qlEditorParent = input.parentElement;\n    if (qlEditorParent) {\n      qlEditorParent.insertBefore(button, input);\n      this.logStrategy(4, true, '(before ql-editor parent)');\n      return true;\n    }\n    this.logStrategy(4, false);\n\n    // Strategy 5: Last resort - insert adjacent to input\n    try {\n      input.insertAdjacentElement('beforebegin', button);\n      this.logStrategy(5, true, '(insertAdjacentElement)');\n      return true;\n    } catch (error) {\n      this.logStrategy(5, false);\n      return false;\n    }\n  }\n\n  /**\n   * Override getPromptValue for Gemini's Quill editor\n   * Quill editor uses contenteditable div, read text via textContent or innerText\n   */\n  getPromptValue(el: HTMLElement): string {\n    // For Quill editor, use textContent to get plain text\n    // This avoids getting HTML markup\n    const text = el.textContent || el.innerText || '';\n    return text.trim();\n  }\n\n  /**\n   * Override setPromptValue for Gemini's Quill editor\n   * Must update innerHTML for Quill and dispatch input event for framework detection\n   */\n  setPromptValue(el: HTMLElement, value: string): void {\n    // For Quill editor, set the HTML content\n    // Wrap in <p> tag as Quill expects block-level elements\n    el.innerHTML = `<p>${this.escapeHtml(value)}</p>`;\n\n    // Dispatch both input and change events to trigger Gemini's framework\n    const inputEvent = new Event('input', { bubbles: true });\n    const changeEvent = new Event('change', { bubbles: true });\n    el.dispatchEvent(inputEvent);\n    el.dispatchEvent(changeEvent);\n\n    console.log('[Prompt Optimizer] Gemini: Updated Quill editor content');\n  }\n\n  /**\n   * Escape HTML special characters to prevent XSS\n   */\n  private escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n}\n", "/**\n * MutationObserver helper for managing button injection across SPAs and DOM changes\n * Prevents duplicate button injection and handles re-mounting after SPA navigation\n */\n\n/**\n * Configuration for the MutationObserver\n */\nconst OBSERVER_CONFIG: MutationObserverInit = {\n  childList: true,\n  subtree: true\n};\n\nconst MAX_RETRY_ATTEMPTS = 100;\n\n/**\n * Creates and manages a MutationObserver for monitoring DOM changes\n * Useful for SPA applications that change the DOM structure\n * @param callback - Function to call when DOM changes are detected\n * @param maxAttempts - Maximum number of times the callback should be triggered (default: 100)\n * @returns A MutationObserver instance (already observing document.body)\n */\nexport function createMutationObserver(\n  callback: () => void,\n  maxAttempts: number = MAX_RETRY_ATTEMPTS\n): MutationObserver {\n  let attempts = 0;\n\n  const observer = new MutationObserver(() => {\n    attempts++;\n    console.log(`[Prompt Optimizer] MutationObserver triggered (attempt ${attempts}/${maxAttempts})`);\n\n    callback();\n\n    if (attempts >= maxAttempts) {\n      console.warn(`[Prompt Optimizer] MutationObserver reached max attempts (${maxAttempts})`);\n      observer.disconnect();\n    }\n  });\n\n  observer.observe(document.body, OBSERVER_CONFIG);\n  return observer;\n}\n\n/**\n * Detects URL changes in SPA applications\n * Useful for sites like Gemini and Manus that are SPAs\n * @param onUrlChange - Function to call when URL changes\n */\nexport function detectUrlChanges(onUrlChange: () => void): void {\n  let lastUrl = location.href;\n\n  const observer = new MutationObserver(() => {\n    if (location.href !== lastUrl) {\n      console.log(`[Prompt Optimizer] URL changed from ${lastUrl} to ${location.href}`);\n      lastUrl = location.href;\n      onUrlChange();\n    }\n  });\n\n  observer.observe(document, { subtree: true, childList: true });\n}\n\n/**\n * Monitors if the input element is still in the DOM\n * If removed, triggers a callback (useful for re-injecting button after input changes)\n * @param inputElement - The input element to monitor\n * @param onRemoved - Function to call if input is removed from DOM\n */\nexport function monitorInputElement(\n  inputElement: HTMLElement,\n  onRemoved: () => void\n): void {\n  const observer = new MutationObserver(() => {\n    if (!document.contains(inputElement)) {\n      console.log('[Prompt Optimizer] Input element was removed from DOM');\n      onRemoved();\n      observer.disconnect();\n    }\n  });\n\n  observer.observe(document.body, OBSERVER_CONFIG);\n}\n", "import { MessageType, isTriggerOptimizeMessage } from '../shared/messages';\nimport {\n  createButton,\n  handleOptimize,\n  buttonExists,\n  removeButton\n} from './shared/button-controller';\nimport { ChatGptHandler } from './sites/chatgpt';\nimport { ManusHandler } from './sites/manus';\nimport { GeminiHandler } from './sites/gemini';\nimport { createMutationObserver } from './shared/mutation-observer-helpers';\nimport type { SiteHandler } from './shared/types';\n\nconst BUTTON_CLASS = 'prompt-enhancer-btn';\n\nconsole.log('[Prompt Optimizer] Content script loaded on:', window.location.href);\n\n// Array of all supported site handlers\nconst handlers: SiteHandler[] = [\n  new ChatGptHandler(),\n  new ManusHandler(),\n  new GeminiHandler()\n];\n\n/**\n * Get the appropriate handler for the current site\n * @returns The handler for the current site, or null if no handler matches\n */\nfunction getActiveHandler(): SiteHandler | null {\n  for (const handler of handlers) {\n    if (handler.shouldActivate()) {\n      return handler;\n    }\n  }\n  return null;\n}\n\n/**\n * Main initialization function\n * Attempts to inject the button immediately, then sets up MutationObserver for SPAs\n */\nfunction mount(): void {\n  console.log('[Prompt Optimizer] mount() called');\n\n  const handler = getActiveHandler();\n  if (!handler) {\n    console.log('[Prompt Optimizer] No supported host detected');\n    return;\n  }\n\n  console.log(`[Prompt Optimizer] \u2705 Active handler: ${handler.name}`);\n\n  // Try to find and inject button immediately\n  const input = handler.findPromptInput();\n  if (input) {\n    console.log('[Prompt Optimizer] Input found immediately');\n    injectButton(handler, input);\n    return;\n  }\n\n  // If not found immediately, set up MutationObserver for SPAs\n  console.log('[Prompt Optimizer] Setting up MutationObserver for SPA navigation...');\n\n  createMutationObserver(\n    () => {\n      // Try again when DOM changes\n      const foundInput = handler.findPromptInput();\n      if (foundInput && !buttonExists()) {\n        console.log('[Prompt Optimizer] Input found via MutationObserver');\n        injectButton(handler, foundInput);\n      }\n    },\n    100  // Max attempts\n  );\n}\n\n/**\n * Inject the button for a given handler and input element\n * @param handler - The site handler\n * @param input - The input element where button should be injected\n */\nfunction injectButton(handler: SiteHandler, input: HTMLElement): void {\n  if (buttonExists()) {\n    console.log('[Prompt Optimizer] Button already exists');\n    return;\n  }\n\n  console.log('[Prompt Optimizer] Creating button...');\n  const button = createButton();\n\n  // Add click listener to button\n  button.addEventListener('click', async () => {\n    await handleOptimize(button, input, handler.getPromptValue.bind(handler), handler.setPromptValue.bind(handler));\n  });\n\n  // Insert button using site-specific handler\n  const success = handler.insertButton(button, input);\n  if (!success) {\n    console.warn('[Prompt Optimizer] All insertion strategies failed');\n    removeButton();\n  }\n}\n\n// Initialize on page load\nif (document.readyState === 'complete' || document.readyState === 'interactive') {\n  console.log('[Prompt Optimizer] Document ready, mounting...');\n  mount();\n} else {\n  console.log('[Prompt Optimizer] Waiting for DOMContentLoaded...');\n  window.addEventListener('DOMContentLoaded', () => {\n    console.log('[Prompt Optimizer] DOMContentLoaded fired');\n    mount();\n  });\n}\n\n// Delayed retry for SPAs\nsetTimeout(() => {\n  console.log('[Prompt Optimizer] Delayed mount attempt (2s)');\n  mount();\n}, 2000);\n\n// Handle keyboard shortcut\nchrome.runtime.onMessage.addListener((message) => {\n  if (isTriggerOptimizeMessage(message)) {\n    console.log('[Prompt Optimizer] Keyboard shortcut triggered');\n    const handler = getActiveHandler();\n    if (!handler) {\n      console.warn('[Prompt Optimizer] No active handler for keyboard shortcut');\n      return;\n    }\n\n    const button = document.querySelector<HTMLButtonElement>(`.${BUTTON_CLASS}`);\n    const target = handler.findPromptInput();\n\n    if (button && target) {\n      handleOptimize(button, target, handler.getPromptValue.bind(handler), handler.setPromptValue.bind(handler));\n    } else {\n      console.warn('[Prompt Optimizer] Cannot handle shortcut - button or input missing');\n    }\n  }\n});\n\nconsole.log('[Prompt Optimizer] Content script initialized');\n"],
  "mappings": "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",
  "names": ["BUTTON_CLASS"]
}
